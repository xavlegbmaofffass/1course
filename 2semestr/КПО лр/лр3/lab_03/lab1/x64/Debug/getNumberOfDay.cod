; Listing generated by Microsoft (R) Optimizing Compiler Version 19.41.34123.0 

include listing.inc

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

msvcjmc	SEGMENT
__A6AAA0F1_lab1@pch DB 01H
__C041DDD8_type_traits DB 01H
__41085817_vector DB 01H
__DEE33341_utility DB 01H
__BD360EEC_getNumberOfDay@cpp DB 01H
__87834AAC_stdafx@h DB 01H
__E7D43BC3_stdafx@cpp DB 01H
msvcjmc	ENDS
PUBLIC	?getNumberOfDay@@YAHHH_N@Z			; getNumberOfDay
PUBLIC	?getNumberByBD@@YAHHHHHH_N@Z			; getNumberByBD
PUBLIC	?getDate@@YA?AU?$pair@HH@std@@H_N@Z		; getDate
PUBLIC	?getHoliday@@YAHH@Z				; getHoliday
PUBLIC	?size@?$vector@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@QEBA_KXZ ; std::vector<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int> > >::size
PUBLIC	??A?$vector@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@QEAAAEAU?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@1@_K@Z ; std::vector<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int> > >::operator[]
PUBLIC	??$make_pair@AEAHAEAH@std@@YA?AU?$pair@HH@0@AEAH0@Z ; std::make_pair<int &,int &>
PUBLIC	??$make_pair@HH@std@@YA?AU?$pair@HH@0@$$QEAH0@Z	; std::make_pair<int,int>
PUBLIC	??$?0AEAHAEAH$0A@@?$pair@HH@std@@QEAA@AEAH0@Z	; std::pair<int,int>::pair<int,int><int &,int &,0>
PUBLIC	??$?0HH$0A@@?$pair@HH@std@@QEAA@$$QEAH0@Z	; std::pair<int,int>::pair<int,int><int,int,0>
PUBLIC	__JustMyCode_Default
PUBLIC	??_C@_02DKCKIIND@?$CFs@				; `string'
PUBLIC	??_C@_11LOCGONAA@@				; `string'
PUBLIC	??_C@_0BO@PFKOHNJC@vector?5subscript?5out?5of?5range@ ; `string'
PUBLIC	??_C@_0GC@DAOINONL@C?3?2Program?5Files?2Microsoft?5Visu@ ; `string'
PUBLIC	??_C@_1ME@BALGBIJ@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@ ; `string'
PUBLIC	??_C@_1EA@LEKOKFNB@?$AA?$CC?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAs?$AAu?$AAb?$AAs?$AAc?$AAr?$AAi@ ; `string'
EXTRN	__imp__invalid_parameter:PROC
EXTRN	__imp__CrtDbgReport:PROC
EXTRN	_RTC_CheckStackVars:PROC
EXTRN	_RTC_InitBase:PROC
EXTRN	_RTC_Shutdown:PROC
EXTRN	__CheckForDebuggerJustMyCode:PROC
EXTRN	__GSHandlerCheck:PROC
EXTRN	__security_check_cookie:PROC
EXTRN	?months@@3V?$vector@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@A:BYTE ; months
EXTRN	?holidays@@3V?$vector@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@A:BYTE ; holidays
EXTRN	__security_cookie:QWORD
;	COMDAT pdata
pdata	SEGMENT
$pdata$?getNumberOfDay@@YAHHH_N@Z DD imagerel $LN7
	DD	imagerel $LN7+175
	DD	imagerel $unwind$?getNumberOfDay@@YAHHH_N@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?getNumberByBD@@YAHHHHHH_N@Z DD imagerel $LN5
	DD	imagerel $LN5+267
	DD	imagerel $unwind$?getNumberByBD@@YAHHHHHH_N@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?getDate@@YA?AU?$pair@HH@std@@H_N@Z DD imagerel $LN13
	DD	imagerel $LN13+471
	DD	imagerel $unwind$?getDate@@YA?AU?$pair@HH@std@@H_N@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?getHoliday@@YAHH@Z DD imagerel $LN7
	DD	imagerel $LN7+139
	DD	imagerel $unwind$?getHoliday@@YAHH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?size@?$vector@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@QEBA_KXZ DD imagerel $LN4
	DD	imagerel $LN4+82
	DD	imagerel $unwind$?size@?$vector@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@QEBA_KXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??A?$vector@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@QEAAAEAU?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@1@_K@Z DD imagerel $LN13
	DD	imagerel $LN13+232
	DD	imagerel $unwind$??A?$vector@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@QEAAAEAU?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@1@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$make_pair@AEAHAEAH@std@@YA?AU?$pair@HH@0@AEAH0@Z DD imagerel $LN4
	DD	imagerel $LN4+86
	DD	imagerel $unwind$??$make_pair@AEAHAEAH@std@@YA?AU?$pair@HH@0@AEAH0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$make_pair@HH@std@@YA?AU?$pair@HH@0@$$QEAH0@Z DD imagerel $LN4
	DD	imagerel $LN4+86
	DD	imagerel $unwind$??$make_pair@HH@std@@YA?AU?$pair@HH@0@$$QEAH0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?0AEAHAEAH$0A@@?$pair@HH@std@@QEAA@AEAH0@Z DD imagerel $LN4
	DD	imagerel $LN4+96
	DD	imagerel $unwind$??$?0AEAHAEAH$0A@@?$pair@HH@std@@QEAA@AEAH0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?0HH$0A@@?$pair@HH@std@@QEAA@$$QEAH0@Z DD imagerel $LN4
	DD	imagerel $LN4+96
	DD	imagerel $unwind$??$?0HH$0A@@?$pair@HH@std@@QEAA@$$QEAH0@Z
pdata	ENDS
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
_RTC_Shutdown.rtc$TMZ DQ FLAT:_RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
_RTC_InitBase.rtc$IMZ DQ FLAT:_RTC_InitBase
rtc$IMZ	ENDS
;	COMDAT ??_C@_1EA@LEKOKFNB@?$AA?$CC?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAs?$AAu?$AAb?$AAs?$AAc?$AAr?$AAi@
CONST	SEGMENT
??_C@_1EA@LEKOKFNB@?$AA?$CC?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAs?$AAu?$AAb?$AAs?$AAc?$AAr?$AAi@ DB '"'
	DB	00H, 'v', 00H, 'e', 00H, 'c', 00H, 't', 00H, 'o', 00H, 'r', 00H
	DB	' ', 00H, 's', 00H, 'u', 00H, 'b', 00H, 's', 00H, 'c', 00H, 'r'
	DB	00H, 'i', 00H, 'p', 00H, 't', 00H, ' ', 00H, 'o', 00H, 'u', 00H
	DB	't', 00H, ' ', 00H, 'o', 00H, 'f', 00H, ' ', 00H, 'r', 00H, 'a'
	DB	00H, 'n', 00H, 'g', 00H, 'e', 00H, '"', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1ME@BALGBIJ@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@
CONST	SEGMENT
??_C@_1ME@BALGBIJ@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@ DB 'C'
	DB	00H, ':', 00H, '\', 00H, 'P', 00H, 'r', 00H, 'o', 00H, 'g', 00H
	DB	'r', 00H, 'a', 00H, 'm', 00H, ' ', 00H, 'F', 00H, 'i', 00H, 'l'
	DB	00H, 'e', 00H, 's', 00H, '\', 00H, 'M', 00H, 'i', 00H, 'c', 00H
	DB	'r', 00H, 'o', 00H, 's', 00H, 'o', 00H, 'f', 00H, 't', 00H, ' '
	DB	00H, 'V', 00H, 'i', 00H, 's', 00H, 'u', 00H, 'a', 00H, 'l', 00H
	DB	' ', 00H, 'S', 00H, 't', 00H, 'u', 00H, 'd', 00H, 'i', 00H, 'o'
	DB	00H, '\', 00H, '2', 00H, '0', 00H, '2', 00H, '2', 00H, '\', 00H
	DB	'E', 00H, 'n', 00H, 't', 00H, 'e', 00H, 'r', 00H, 'p', 00H, 'r'
	DB	00H, 'i', 00H, 's', 00H, 'e', 00H, '\', 00H, 'V', 00H, 'C', 00H
	DB	'\', 00H, 'T', 00H, 'o', 00H, 'o', 00H, 'l', 00H, 's', 00H, '\'
	DB	00H, 'M', 00H, 'S', 00H, 'V', 00H, 'C', 00H, '\', 00H, '1', 00H
	DB	'4', 00H, '.', 00H, '4', 00H, '1', 00H, '.', 00H, '3', 00H, '4'
	DB	00H, '1', 00H, '2', 00H, '0', 00H, '\', 00H, 'i', 00H, 'n', 00H
	DB	'c', 00H, 'l', 00H, 'u', 00H, 'd', 00H, 'e', 00H, '\', 00H, 'v'
	DB	00H, 'e', 00H, 'c', 00H, 't', 00H, 'o', 00H, 'r', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0GC@DAOINONL@C?3?2Program?5Files?2Microsoft?5Visu@
CONST	SEGMENT
??_C@_0GC@DAOINONL@C?3?2Program?5Files?2Microsoft?5Visu@ DB 'C:\Program F'
	DB	'iles\Microsoft Visual Studio\2022\Enterprise\VC\Tools\MSVC\14'
	DB	'.41.34120\include\vector', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@PFKOHNJC@vector?5subscript?5out?5of?5range@
CONST	SEGMENT
??_C@_0BO@PFKOHNJC@vector?5subscript?5out?5of?5range@ DB 'vector subscrip'
	DB	't out of range', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_11LOCGONAA@@
CONST	SEGMENT
??_C@_11LOCGONAA@@ DB 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_02DKCKIIND@?$CFs@
CONST	SEGMENT
??_C@_02DKCKIIND@?$CFs@ DB '%s', 00H			; `string'
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?0HH$0A@@?$pair@HH@std@@QEAA@$$QEAH0@Z DD 025051d01H
	DD	0118231dH
	DD	07011001dH
	DD	05010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?0AEAHAEAH$0A@@?$pair@HH@std@@QEAA@AEAH0@Z DD 025051d01H
	DD	0118231dH
	DD	07011001dH
	DD	05010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$make_pair@HH@std@@YA?AU?$pair@HH@0@$$QEAH0@Z DD 025051d01H
	DD	0118231dH
	DD	07011001dH
	DD	05010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$make_pair@AEAHAEAH@std@@YA?AU?$pair@HH@0@AEAH0@Z DD 025051d01H
	DD	0118231dH
	DD	07011001dH
	DD	05010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??A?$vector@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@QEAAAEAU?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@1@_K@Z DD 035051801H
	DD	01133318H
	DD	0700c0023H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?size@?$vector@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@QEBA_KXZ DD 025051301H
	DD	010e2313H
	DD	070070021H
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?getHoliday@@YAHH@Z DD 025051201H
	DD	010d2312H
	DD	070060025H
	DD	05005H
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	03fH
	DW	01beH
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?getDate@@YA?AU?$pair@HH@std@@H_N@Z DD 025054619H
	DD	0117231cH
	DD	070100033H
	DD	0500fH
	DD	imagerel __GSHandlerCheck
	DD	0180H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
?getDate@@YA?AU?$pair@HH@std@@H_N@Z$rtcName$0 DB 06dH	; getDate
	DB	06fH
	DB	06eH
	DB	074H
	DB	068H
	DB	049H
	DB	06eH
	DB	064H
	DB	065H
	DB	078H
	DB	00H
	ORG $+5
?getDate@@YA?AU?$pair@HH@std@@H_N@Z$rtcVarDesc DD 044H	; getDate
	DD	04H
	DQ	FLAT:?getDate@@YA?AU?$pair@HH@std@@H_N@Z$rtcName$0
	ORG $+48
?getDate@@YA?AU?$pair@HH@std@@H_N@Z$rtcFrameData DD 01H	; getDate
	DD	00H
	DQ	FLAT:?getDate@@YA?AU?$pair@HH@std@@H_N@Z$rtcVarDesc
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?getNumberByBD@@YAHHHHHH_N@Z DD 025052001H
	DD	011b2320H
	DD	070140021H
	DD	05013H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?getNumberOfDay@@YAHHH_N@Z DD 025051b01H
	DD	0116231bH
	DD	0700f0025H
	DD	0500eH
xdata	ENDS
; Function compile flags: /Odt
;	COMDAT __JustMyCode_Default
_TEXT	SEGMENT
__JustMyCode_Default PROC				; COMDAT
  00000	c2 00 00	 ret	 0
__JustMyCode_Default ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Enterprise\VC\Tools\MSVC\14.41.34120\include\utility
;	COMDAT ??$?0HH$0A@@?$pair@HH@std@@QEAA@$$QEAH0@Z
_TEXT	SEGMENT
this$ = 224
_Val1$ = 232
_Val2$ = 240
??$?0HH$0A@@?$pair@HH@std@@QEAA@$$QEAH0@Z PROC		; std::pair<int,int>::pair<int,int><int,int,0>, COMDAT

; 247  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {

$LN4:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	55		 push	 rbp
  00010	57		 push	 rdi
  00011	48 81 ec e8 00
	00 00		 sub	 rsp, 232		; 000000e8H
  00018	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0001d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__DEE33341_utility
  00024	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode
  00029	90		 npad	 1
  0002a	48 8b 85 e0 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  00031	48 8b 8d e8 00
	00 00		 mov	 rcx, QWORD PTR _Val1$[rbp]
  00038	8b 09		 mov	 ecx, DWORD PTR [rcx]
  0003a	89 08		 mov	 DWORD PTR [rax], ecx
  0003c	48 8b 85 e0 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  00043	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR _Val2$[rbp]
  0004a	8b 09		 mov	 ecx, DWORD PTR [rcx]
  0004c	89 48 04	 mov	 DWORD PTR [rax+4], ecx

; 248  :     }

  0004f	48 8b 85 e0 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  00056	48 8d a5 c8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+200]
  0005d	5f		 pop	 rdi
  0005e	5d		 pop	 rbp
  0005f	c3		 ret	 0
??$?0HH$0A@@?$pair@HH@std@@QEAA@$$QEAH0@Z ENDP		; std::pair<int,int>::pair<int,int><int,int,0>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Enterprise\VC\Tools\MSVC\14.41.34120\include\utility
;	COMDAT ??$?0AEAHAEAH$0A@@?$pair@HH@std@@QEAA@AEAH0@Z
_TEXT	SEGMENT
this$ = 224
_Val1$ = 232
_Val2$ = 240
??$?0AEAHAEAH$0A@@?$pair@HH@std@@QEAA@AEAH0@Z PROC	; std::pair<int,int>::pair<int,int><int &,int &,0>, COMDAT

; 247  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {

$LN4:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	55		 push	 rbp
  00010	57		 push	 rdi
  00011	48 81 ec e8 00
	00 00		 sub	 rsp, 232		; 000000e8H
  00018	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0001d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__DEE33341_utility
  00024	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode
  00029	90		 npad	 1
  0002a	48 8b 85 e0 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  00031	48 8b 8d e8 00
	00 00		 mov	 rcx, QWORD PTR _Val1$[rbp]
  00038	8b 09		 mov	 ecx, DWORD PTR [rcx]
  0003a	89 08		 mov	 DWORD PTR [rax], ecx
  0003c	48 8b 85 e0 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  00043	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR _Val2$[rbp]
  0004a	8b 09		 mov	 ecx, DWORD PTR [rcx]
  0004c	89 48 04	 mov	 DWORD PTR [rax+4], ecx

; 248  :     }

  0004f	48 8b 85 e0 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  00056	48 8d a5 c8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+200]
  0005d	5f		 pop	 rdi
  0005e	5d		 pop	 rbp
  0005f	c3		 ret	 0
??$?0AEAHAEAH$0A@@?$pair@HH@std@@QEAA@AEAH0@Z ENDP	; std::pair<int,int>::pair<int,int><int &,int &,0>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Enterprise\VC\Tools\MSVC\14.41.34120\include\utility
;	COMDAT ??$make_pair@HH@std@@YA?AU?$pair@HH@0@$$QEAH0@Z
_TEXT	SEGMENT
__$ReturnUdt$ = 224
_Val1$ = 232
_Val2$ = 240
??$make_pair@HH@std@@YA?AU?$pair@HH@0@$$QEAH0@Z PROC	; std::make_pair<int,int>, COMDAT

; 558  :     && is_nothrow_constructible_v<_Unrefwrap_t<_Ty2>, _Ty2>) /* strengthened */ {

$LN4:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	55		 push	 rbp
  00010	57		 push	 rdi
  00011	48 81 ec e8 00
	00 00		 sub	 rsp, 232		; 000000e8H
  00018	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0001d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__DEE33341_utility
  00024	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode
  00029	90		 npad	 1

; 559  :     // return pair composed from arguments
; 560  :     using _Mypair = pair<_Unrefwrap_t<_Ty1>, _Unrefwrap_t<_Ty2>>;
; 561  :     return _Mypair(_STD forward<_Ty1>(_Val1), _STD forward<_Ty2>(_Val2));

  0002a	4c 8b 85 f0 00
	00 00		 mov	 r8, QWORD PTR _Val2$[rbp]
  00031	48 8b 95 e8 00
	00 00		 mov	 rdx, QWORD PTR _Val1$[rbp]
  00038	48 8b 8d e0 00
	00 00		 mov	 rcx, QWORD PTR __$ReturnUdt$[rbp]
  0003f	e8 00 00 00 00	 call	 ??$?0HH$0A@@?$pair@HH@std@@QEAA@$$QEAH0@Z ; std::pair<int,int>::pair<int,int><int,int,0>
  00044	90		 npad	 1
  00045	48 8b 85 e0 00
	00 00		 mov	 rax, QWORD PTR __$ReturnUdt$[rbp]

; 562  : }

  0004c	48 8d a5 c8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+200]
  00053	5f		 pop	 rdi
  00054	5d		 pop	 rbp
  00055	c3		 ret	 0
??$make_pair@HH@std@@YA?AU?$pair@HH@0@$$QEAH0@Z ENDP	; std::make_pair<int,int>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Enterprise\VC\Tools\MSVC\14.41.34120\include\utility
;	COMDAT ??$make_pair@AEAHAEAH@std@@YA?AU?$pair@HH@0@AEAH0@Z
_TEXT	SEGMENT
__$ReturnUdt$ = 224
_Val1$ = 232
_Val2$ = 240
??$make_pair@AEAHAEAH@std@@YA?AU?$pair@HH@0@AEAH0@Z PROC ; std::make_pair<int &,int &>, COMDAT

; 558  :     && is_nothrow_constructible_v<_Unrefwrap_t<_Ty2>, _Ty2>) /* strengthened */ {

$LN4:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	55		 push	 rbp
  00010	57		 push	 rdi
  00011	48 81 ec e8 00
	00 00		 sub	 rsp, 232		; 000000e8H
  00018	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0001d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__DEE33341_utility
  00024	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode
  00029	90		 npad	 1

; 559  :     // return pair composed from arguments
; 560  :     using _Mypair = pair<_Unrefwrap_t<_Ty1>, _Unrefwrap_t<_Ty2>>;
; 561  :     return _Mypair(_STD forward<_Ty1>(_Val1), _STD forward<_Ty2>(_Val2));

  0002a	4c 8b 85 f0 00
	00 00		 mov	 r8, QWORD PTR _Val2$[rbp]
  00031	48 8b 95 e8 00
	00 00		 mov	 rdx, QWORD PTR _Val1$[rbp]
  00038	48 8b 8d e0 00
	00 00		 mov	 rcx, QWORD PTR __$ReturnUdt$[rbp]
  0003f	e8 00 00 00 00	 call	 ??$?0AEAHAEAH$0A@@?$pair@HH@std@@QEAA@AEAH0@Z ; std::pair<int,int>::pair<int,int><int &,int &,0>
  00044	90		 npad	 1
  00045	48 8b 85 e0 00
	00 00		 mov	 rax, QWORD PTR __$ReturnUdt$[rbp]

; 562  : }

  0004c	48 8d a5 c8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+200]
  00053	5f		 pop	 rdi
  00054	5d		 pop	 rbp
  00055	c3		 ret	 0
??$make_pair@AEAHAEAH@std@@YA?AU?$pair@HH@0@AEAH0@Z ENDP ; std::make_pair<int &,int &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Enterprise\VC\Tools\MSVC\14.41.34120\include\vector
;	COMDAT ??A?$vector@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@QEAAAEAU?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@1@_K@Z
_TEXT	SEGMENT
_My_data$ = 8
this$ = 256
_Pos$ = 264
??A?$vector@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@QEAAAEAU?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@1@_K@Z PROC ; std::vector<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int> > >::operator[], COMDAT

; 1885 :     _NODISCARD _CONSTEXPR20 _Ty& operator[](const size_type _Pos) noexcept /* strengthened */ {

$LN13:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	57		 push	 rdi
  0000c	48 81 ec 18 01
	00 00		 sub	 rsp, 280		; 00000118H
  00013	48 8d 6c 24 30	 lea	 rbp, QWORD PTR [rsp+48]
  00018	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__41085817_vector
  0001f	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode
  00024	90		 npad	 1

; 1886 :         auto& _My_data = _Mypair._Myval2;

  00025	48 8b 85 00 01
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  0002c	48 89 45 08	 mov	 QWORD PTR _My_data$[rbp], rax
$LN4@operator:

; 1887 : #if _CONTAINER_DEBUG_LEVEL > 0
; 1888 :         _STL_VERIFY(

  00030	48 8b 45 08	 mov	 rax, QWORD PTR _My_data$[rbp]
  00034	48 8b 4d 08	 mov	 rcx, QWORD PTR _My_data$[rbp]
  00038	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  0003c	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00040	48 2b c1	 sub	 rax, rcx
  00043	48 99		 cdq
  00045	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  0004a	48 f7 f9	 idiv	 rcx
  0004d	48 39 85 08 01
	00 00		 cmp	 QWORD PTR _Pos$[rbp], rax
  00054	73 02		 jae	 SHORT $LN7@operator
  00056	eb 6c		 jmp	 SHORT $LN9@operator
$LN7@operator:
  00058	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BO@PFKOHNJC@vector?5subscript?5out?5of?5range@
  0005f	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00064	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_02DKCKIIND@?$CFs@
  0006b	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00070	45 33 c9	 xor	 r9d, r9d
  00073	41 b8 61 07 00
	00		 mov	 r8d, 1889		; 00000761H
  00079	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0GC@DAOINONL@C?3?2Program?5Files?2Microsoft?5Visu@
  00080	b9 02 00 00 00	 mov	 ecx, 2
  00085	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__CrtDbgReport
  0008b	83 f8 01	 cmp	 eax, 1
  0008e	75 03		 jne	 SHORT $LN11@operator
  00090	cc		 int	 3
  00091	33 c0		 xor	 eax, eax
$LN11@operator:
  00093	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR [rsp+32], 0
  0009c	41 b9 61 07 00
	00		 mov	 r9d, 1889		; 00000761H
  000a2	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_1ME@BALGBIJ@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@
  000a9	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_11LOCGONAA@@
  000b0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1EA@LEKOKFNB@?$AA?$CC?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAs?$AAu?$AAb?$AAs?$AAc?$AAr?$AAi@
  000b7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__invalid_parameter
  000bd	90		 npad	 1
  000be	33 c0		 xor	 eax, eax
  000c0	85 c0		 test	 eax, eax
  000c2	75 94		 jne	 SHORT $LN7@operator
$LN9@operator:
  000c4	33 c0		 xor	 eax, eax
  000c6	85 c0		 test	 eax, eax
  000c8	0f 85 62 ff ff
	ff		 jne	 $LN4@operator

; 1889 :             _Pos < static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst), "vector subscript out of range");
; 1890 : #endif // _CONTAINER_DEBUG_LEVEL > 0
; 1891 : 
; 1892 :         return _My_data._Myfirst[_Pos];

  000ce	48 6b 85 08 01
	00 00 30	 imul	 rax, QWORD PTR _Pos$[rbp], 48 ; 00000030H
  000d6	48 8b 4d 08	 mov	 rcx, QWORD PTR _My_data$[rbp]
  000da	48 03 41 08	 add	 rax, QWORD PTR [rcx+8]

; 1893 :     }

  000de	48 8d a5 e8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+232]
  000e5	5f		 pop	 rdi
  000e6	5d		 pop	 rbp
  000e7	c3		 ret	 0
??A?$vector@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@QEAAAEAU?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@1@_K@Z ENDP ; std::vector<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int> > >::operator[]
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Enterprise\VC\Tools\MSVC\14.41.34120\include\vector
;	COMDAT ?size@?$vector@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@QEBA_KXZ
_TEXT	SEGMENT
_My_data$ = 8
this$ = 256
?size@?$vector@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@QEBA_KXZ PROC ; std::vector<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int> > >::size, COMDAT

; 1871 :     _NODISCARD _CONSTEXPR20 size_type size() const noexcept {

$LN4:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	57		 push	 rdi
  00007	48 81 ec 08 01
	00 00		 sub	 rsp, 264		; 00000108H
  0000e	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00013	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__41085817_vector
  0001a	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode
  0001f	90		 npad	 1

; 1872 :         auto& _My_data = _Mypair._Myval2;

  00020	48 8b 85 00 01
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  00027	48 89 45 08	 mov	 QWORD PTR _My_data$[rbp], rax

; 1873 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

  0002b	48 8b 45 08	 mov	 rax, QWORD PTR _My_data$[rbp]
  0002f	48 8b 4d 08	 mov	 rcx, QWORD PTR _My_data$[rbp]
  00033	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  00037	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  0003b	48 2b c1	 sub	 rax, rcx
  0003e	48 99		 cdq
  00040	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00045	48 f7 f9	 idiv	 rcx

; 1874 :     }

  00048	48 8d a5 e8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+232]
  0004f	5f		 pop	 rdi
  00050	5d		 pop	 rbp
  00051	c3		 ret	 0
?size@?$vector@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@QEBA_KXZ ENDP ; std::vector<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int> > >::size
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\учеба\КПО лр\лр3\lab_03\lab1\getNumberOfDay.cpp
;	COMDAT ?getHoliday@@YAHH@Z
_TEXT	SEGMENT
flag$ = 4
i$1 = 36
tv65 = 248
number$ = 288
?getHoliday@@YAHH@Z PROC				; getHoliday, COMDAT

; 52   : int getHoliday(int number) {

$LN7:
  00000	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00004	55		 push	 rbp
  00005	57		 push	 rdi
  00006	48 81 ec 28 01
	00 00		 sub	 rsp, 296		; 00000128H
  0000d	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00012	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__BD360EEC_getNumberOfDay@cpp
  00019	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode
  0001e	90		 npad	 1

; 53   : 	bool flag = false;

  0001f	c6 45 04 00	 mov	 BYTE PTR flag$[rbp], 0

; 54   : 	for (int i = 0; i != holidays.size(); ++i) {

  00023	c7 45 24 00 00
	00 00		 mov	 DWORD PTR i$1[rbp], 0
  0002a	eb 08		 jmp	 SHORT $LN4@getHoliday
$LN2@getHoliday:
  0002c	8b 45 24	 mov	 eax, DWORD PTR i$1[rbp]
  0002f	ff c0		 inc	 eax
  00031	89 45 24	 mov	 DWORD PTR i$1[rbp], eax
$LN4@getHoliday:
  00034	48 63 45 24	 movsxd	 rax, DWORD PTR i$1[rbp]
  00038	48 89 85 f8 00
	00 00		 mov	 QWORD PTR tv65[rbp], rax
  0003f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?holidays@@3V?$vector@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@A ; holidays
  00046	e8 00 00 00 00	 call	 ?size@?$vector@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@QEBA_KXZ ; std::vector<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int> > >::size
  0004b	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR tv65[rbp]
  00052	48 3b c8	 cmp	 rcx, rax
  00055	74 25		 je	 SHORT $LN3@getHoliday

; 55   : 		if (number == holidays[i].second) {

  00057	48 63 45 24	 movsxd	 rax, DWORD PTR i$1[rbp]
  0005b	48 8b d0	 mov	 rdx, rax
  0005e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?holidays@@3V?$vector@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@A ; holidays
  00065	e8 00 00 00 00	 call	 ??A?$vector@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@QEAAAEAU?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@1@_K@Z ; std::vector<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int> > >::operator[]
  0006a	8b 40 28	 mov	 eax, DWORD PTR [rax+40]
  0006d	39 85 20 01 00
	00		 cmp	 DWORD PTR number$[rbp], eax
  00073	75 05		 jne	 SHORT $LN5@getHoliday

; 56   : 			return i;

  00075	8b 45 24	 mov	 eax, DWORD PTR i$1[rbp]
  00078	eb 07		 jmp	 SHORT $LN1@getHoliday
$LN5@getHoliday:

; 57   : 		}
; 58   : 	}

  0007a	eb b0		 jmp	 SHORT $LN2@getHoliday
$LN3@getHoliday:

; 59   : 	return -1;

  0007c	b8 ff ff ff ff	 mov	 eax, -1
$LN1@getHoliday:

; 60   : }

  00081	48 8d a5 08 01
	00 00		 lea	 rsp, QWORD PTR [rbp+264]
  00088	5f		 pop	 rdi
  00089	5d		 pop	 rbp
  0008a	c3		 ret	 0
?getHoliday@@YAHH@Z ENDP				; getHoliday
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\учеба\КПО лр\лр3\lab_03\lab1\getNumberOfDay.cpp
;	COMDAT ?getDate@@YA?AU?$pair@HH@std@@H_N@Z
_TEXT	SEGMENT
i$4 = 4
monthIndex$ = 36
i$5 = 68
$T6 = 292
$T7 = 324
tv67 = 344
tv82 = 344
__$ArrayPad$ = 352
__$ReturnUdt$ = 400
number$ = 408
isLeap$ = 416
?getDate@@YA?AU?$pair@HH@std@@H_N@Z PROC		; getDate, COMDAT

; 28   : pair<int, int> getDate(int number, bool isLeap) {

$LN13:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	55		 push	 rbp
  0000f	57		 push	 rdi
  00010	48 81 ec 98 01
	00 00		 sub	 rsp, 408		; 00000198H
  00017	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0001c	48 8d 7c 24 20	 lea	 rdi, QWORD PTR [rsp+32]
  00021	b9 2e 00 00 00	 mov	 ecx, 46			; 0000002eH
  00026	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002b	f3 ab		 rep stosd
  0002d	48 8b 8c 24 b8
	01 00 00	 mov	 rcx, QWORD PTR [rsp+440]
  00035	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0003c	48 33 c5	 xor	 rax, rbp
  0003f	48 89 85 60 01
	00 00		 mov	 QWORD PTR __$ArrayPad$[rbp], rax
  00046	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__BD360EEC_getNumberOfDay@cpp
  0004d	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode
  00052	90		 npad	 1

; 29   : 	if (isLeap) { // Увеличиваем порядковый номер праздника после 29-го февраля если год високосный

  00053	0f b6 85 a0 01
	00 00		 movzx	 eax, BYTE PTR isLeap$[rbp]
  0005a	85 c0		 test	 eax, eax
  0005c	0f 84 81 00 00
	00		 je	 $LN8@getDate

; 30   : 		for (int i = 0; i != holidays.size(); ++i) {

  00062	c7 45 04 00 00
	00 00		 mov	 DWORD PTR i$4[rbp], 0
  00069	eb 08		 jmp	 SHORT $LN4@getDate
$LN2@getDate:
  0006b	8b 45 04	 mov	 eax, DWORD PTR i$4[rbp]
  0006e	ff c0		 inc	 eax
  00070	89 45 04	 mov	 DWORD PTR i$4[rbp], eax
$LN4@getDate:
  00073	48 63 45 04	 movsxd	 rax, DWORD PTR i$4[rbp]
  00077	48 89 85 58 01
	00 00		 mov	 QWORD PTR tv67[rbp], rax
  0007e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?holidays@@3V?$vector@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@A ; holidays
  00085	e8 00 00 00 00	 call	 ?size@?$vector@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@QEBA_KXZ ; std::vector<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int> > >::size
  0008a	48 8b 8d 58 01
	00 00		 mov	 rcx, QWORD PTR tv67[rbp]
  00091	48 3b c8	 cmp	 rcx, rax
  00094	74 4d		 je	 SHORT $LN3@getDate

; 31   : 			if (holidays[i].second >= 59) {

  00096	48 63 45 04	 movsxd	 rax, DWORD PTR i$4[rbp]
  0009a	48 8b d0	 mov	 rdx, rax
  0009d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?holidays@@3V?$vector@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@A ; holidays
  000a4	e8 00 00 00 00	 call	 ??A?$vector@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@QEAAAEAU?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@1@_K@Z ; std::vector<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int> > >::operator[]
  000a9	83 78 28 3b	 cmp	 DWORD PTR [rax+40], 59	; 0000003bH
  000ad	7c 32		 jl	 SHORT $LN9@getDate

; 32   : 				holidays[i].second++;

  000af	48 63 45 04	 movsxd	 rax, DWORD PTR i$4[rbp]
  000b3	48 8b d0	 mov	 rdx, rax
  000b6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?holidays@@3V?$vector@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@A ; holidays
  000bd	e8 00 00 00 00	 call	 ??A?$vector@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@QEAAAEAU?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@1@_K@Z ; std::vector<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int> > >::operator[]
  000c2	48 83 c0 28	 add	 rax, 40			; 00000028H
  000c6	48 89 85 58 01
	00 00		 mov	 QWORD PTR tv82[rbp], rax
  000cd	48 8b 85 58 01
	00 00		 mov	 rax, QWORD PTR tv82[rbp]
  000d4	8b 00		 mov	 eax, DWORD PTR [rax]
  000d6	ff c0		 inc	 eax
  000d8	48 8b 8d 58 01
	00 00		 mov	 rcx, QWORD PTR tv82[rbp]
  000df	89 01		 mov	 DWORD PTR [rcx], eax
$LN9@getDate:

; 33   : 			}
; 34   : 		}

  000e1	eb 88		 jmp	 SHORT $LN2@getDate
$LN3@getDate:
$LN8@getDate:

; 35   : 	}
; 36   : 
; 37   : 	int monthIndex = 0;

  000e3	c7 45 24 00 00
	00 00		 mov	 DWORD PTR monthIndex$[rbp], 0

; 38   : 	for (int i = 0; i != 12; ++i) {

  000ea	c7 45 44 00 00
	00 00		 mov	 DWORD PTR i$5[rbp], 0
  000f1	eb 08		 jmp	 SHORT $LN7@getDate
$LN5@getDate:
  000f3	8b 45 44	 mov	 eax, DWORD PTR i$5[rbp]
  000f6	ff c0		 inc	 eax
  000f8	89 45 44	 mov	 DWORD PTR i$5[rbp], eax
$LN7@getDate:
  000fb	83 7d 44 0c	 cmp	 DWORD PTR i$5[rbp], 12
  000ff	74 71		 je	 SHORT $LN6@getDate

; 39   : 		if (number > months[i].second) {

  00101	48 63 45 44	 movsxd	 rax, DWORD PTR i$5[rbp]
  00105	48 8b d0	 mov	 rdx, rax
  00108	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?months@@3V?$vector@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@A ; months
  0010f	e8 00 00 00 00	 call	 ??A?$vector@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@QEAAAEAU?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@1@_K@Z ; std::vector<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int> > >::operator[]
  00114	8b 40 28	 mov	 eax, DWORD PTR [rax+40]
  00117	39 85 98 01 00
	00		 cmp	 DWORD PTR number$[rbp], eax
  0011d	7e 30		 jle	 SHORT $LN10@getDate

; 40   : 			number -= months[i].second;

  0011f	48 63 45 44	 movsxd	 rax, DWORD PTR i$5[rbp]
  00123	48 8b d0	 mov	 rdx, rax
  00126	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?months@@3V?$vector@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@A ; months
  0012d	e8 00 00 00 00	 call	 ??A?$vector@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@QEAAAEAU?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@1@_K@Z ; std::vector<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int> > >::operator[]
  00132	8b 40 28	 mov	 eax, DWORD PTR [rax+40]
  00135	8b 8d 98 01 00
	00		 mov	 ecx, DWORD PTR number$[rbp]
  0013b	2b c8		 sub	 ecx, eax
  0013d	8b c1		 mov	 eax, ecx
  0013f	89 85 98 01 00
	00		 mov	 DWORD PTR number$[rbp], eax

; 41   : 			monthIndex++;

  00145	8b 45 24	 mov	 eax, DWORD PTR monthIndex$[rbp]
  00148	ff c0		 inc	 eax
  0014a	89 45 24	 mov	 DWORD PTR monthIndex$[rbp], eax

; 42   : 		}

  0014d	eb 21		 jmp	 SHORT $LN11@getDate
$LN10@getDate:

; 43   : 		else {
; 44   : 			return make_pair(number, monthIndex);

  0014f	4c 8d 45 24	 lea	 r8, QWORD PTR monthIndex$[rbp]
  00153	48 8d 95 98 01
	00 00		 lea	 rdx, QWORD PTR number$[rbp]
  0015a	48 8b 8d 90 01
	00 00		 mov	 rcx, QWORD PTR __$ReturnUdt$[rbp]
  00161	e8 00 00 00 00	 call	 ??$make_pair@AEAHAEAH@std@@YA?AU?$pair@HH@0@AEAH0@Z ; std::make_pair<int &,int &>
  00166	90		 npad	 1
  00167	48 8b 85 90 01
	00 00		 mov	 rax, QWORD PTR __$ReturnUdt$[rbp]
  0016e	eb 38		 jmp	 SHORT $LN1@getDate
$LN11@getDate:

; 45   : 		}
; 46   : 	}

  00170	eb 81		 jmp	 SHORT $LN5@getDate
$LN6@getDate:

; 47   : 
; 48   : 
; 49   : 	return make_pair(0, 0);

  00172	c7 85 24 01 00
	00 00 00 00 00	 mov	 DWORD PTR $T6[rbp], 0
  0017c	c7 85 44 01 00
	00 00 00 00 00	 mov	 DWORD PTR $T7[rbp], 0
  00186	4c 8d 85 24 01
	00 00		 lea	 r8, QWORD PTR $T6[rbp]
  0018d	48 8d 95 44 01
	00 00		 lea	 rdx, QWORD PTR $T7[rbp]
  00194	48 8b 8d 90 01
	00 00		 mov	 rcx, QWORD PTR __$ReturnUdt$[rbp]
  0019b	e8 00 00 00 00	 call	 ??$make_pair@HH@std@@YA?AU?$pair@HH@0@$$QEAH0@Z ; std::make_pair<int,int>
  001a0	90		 npad	 1
  001a1	48 8b 85 90 01
	00 00		 mov	 rax, QWORD PTR __$ReturnUdt$[rbp]
$LN1@getDate:

; 50   : }

  001a8	48 8b f8	 mov	 rdi, rax
  001ab	48 8d 4d e0	 lea	 rcx, QWORD PTR [rbp-32]
  001af	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?getDate@@YA?AU?$pair@HH@std@@H_N@Z$rtcFrameData
  001b6	e8 00 00 00 00	 call	 _RTC_CheckStackVars
  001bb	48 8b c7	 mov	 rax, rdi
  001be	48 8b 8d 60 01
	00 00		 mov	 rcx, QWORD PTR __$ArrayPad$[rbp]
  001c5	48 33 cd	 xor	 rcx, rbp
  001c8	e8 00 00 00 00	 call	 __security_check_cookie
  001cd	48 8d a5 78 01
	00 00		 lea	 rsp, QWORD PTR [rbp+376]
  001d4	5f		 pop	 rdi
  001d5	5d		 pop	 rbp
  001d6	c3		 ret	 0
?getDate@@YA?AU?$pair@HH@std@@H_N@Z ENDP		; getDate
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\учеба\КПО лр\лр3\lab_03\lab1\getNumberOfDay.cpp
;	COMDAT ?getNumberByBD@@YAHHHHHH_N@Z
_TEXT	SEGMENT
daysBefore$1 = 4
tv71 = 212
tv81 = 212
currentDay$ = 256
currentMonth$ = 264
currentYear$ = 272
BDDay$ = 280
BDMonth$ = 288
isLeap$ = 296
?getNumberByBD@@YAHHHHHH_N@Z PROC			; getNumberByBD, COMDAT

; 16   : int getNumberByBD(int currentDay, int currentMonth, int currentYear, int BDDay, int BDMonth, bool isLeap) {

$LN5:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00012	55		 push	 rbp
  00013	57		 push	 rdi
  00014	48 81 ec 08 01
	00 00		 sub	 rsp, 264		; 00000108H
  0001b	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00020	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__BD360EEC_getNumberOfDay@cpp
  00027	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode
  0002c	90		 npad	 1

; 17   : 	if (BDDay == 29 && BDMonth == 2) {

  0002d	83 bd 18 01 00
	00 1d		 cmp	 DWORD PTR BDDay$[rbp], 29
  00034	0f 85 85 00 00
	00		 jne	 $LN2@getNumberB
  0003a	83 bd 20 01 00
	00 02		 cmp	 DWORD PTR BDMonth$[rbp], 2
  00041	75 7c		 jne	 SHORT $LN2@getNumberB

; 18   : 		int daysBefore = (4 - (currentYear % 4)) * 365;

  00043	8b 85 10 01 00
	00		 mov	 eax, DWORD PTR currentYear$[rbp]
  00049	99		 cdq
  0004a	83 e2 03	 and	 edx, 3
  0004d	03 c2		 add	 eax, edx
  0004f	83 e0 03	 and	 eax, 3
  00052	2b c2		 sub	 eax, edx
  00054	b9 04 00 00 00	 mov	 ecx, 4
  00059	2b c8		 sub	 ecx, eax
  0005b	8b c1		 mov	 eax, ecx
  0005d	69 c0 6d 01 00
	00		 imul	 eax, eax, 365		; 0000016dH
  00063	89 45 04	 mov	 DWORD PTR daysBefore$1[rbp], eax

; 19   : 		if (isLeap) {

  00066	0f b6 85 28 01
	00 00		 movzx	 eax, BYTE PTR isLeap$[rbp]
  0006d	85 c0		 test	 eax, eax
  0006f	74 07		 je	 SHORT $LN3@getNumberB

; 20   : 			daysBefore = 0;

  00071	c7 45 04 00 00
	00 00		 mov	 DWORD PTR daysBefore$1[rbp], 0
$LN3@getNumberB:

; 21   : 		}
; 22   : 		return getNumberOfDay(BDDay, BDMonth, isLeap) - getNumberOfDay(currentDay, currentMonth, isLeap) + daysBefore;

  00078	44 0f b6 85 28
	01 00 00	 movzx	 r8d, BYTE PTR isLeap$[rbp]
  00080	8b 95 20 01 00
	00		 mov	 edx, DWORD PTR BDMonth$[rbp]
  00086	8b 8d 18 01 00
	00		 mov	 ecx, DWORD PTR BDDay$[rbp]
  0008c	e8 00 00 00 00	 call	 ?getNumberOfDay@@YAHHH_N@Z ; getNumberOfDay
  00091	89 85 d4 00 00
	00		 mov	 DWORD PTR tv71[rbp], eax
  00097	44 0f b6 85 28
	01 00 00	 movzx	 r8d, BYTE PTR isLeap$[rbp]
  0009f	8b 95 08 01 00
	00		 mov	 edx, DWORD PTR currentMonth$[rbp]
  000a5	8b 8d 00 01 00
	00		 mov	 ecx, DWORD PTR currentDay$[rbp]
  000ab	e8 00 00 00 00	 call	 ?getNumberOfDay@@YAHHH_N@Z ; getNumberOfDay
  000b0	8b 8d d4 00 00
	00		 mov	 ecx, DWORD PTR tv71[rbp]
  000b6	2b c8		 sub	 ecx, eax
  000b8	8b c1		 mov	 eax, ecx
  000ba	03 45 04	 add	 eax, DWORD PTR daysBefore$1[rbp]
  000bd	eb 42		 jmp	 SHORT $LN1@getNumberB
$LN2@getNumberB:

; 23   : 	}
; 24   : 
; 25   : 	return getNumberOfDay(BDDay, BDMonth, isLeap) - getNumberOfDay(currentDay, currentMonth, isLeap);

  000bf	44 0f b6 85 28
	01 00 00	 movzx	 r8d, BYTE PTR isLeap$[rbp]
  000c7	8b 95 20 01 00
	00		 mov	 edx, DWORD PTR BDMonth$[rbp]
  000cd	8b 8d 18 01 00
	00		 mov	 ecx, DWORD PTR BDDay$[rbp]
  000d3	e8 00 00 00 00	 call	 ?getNumberOfDay@@YAHHH_N@Z ; getNumberOfDay
  000d8	89 85 d4 00 00
	00		 mov	 DWORD PTR tv81[rbp], eax
  000de	44 0f b6 85 28
	01 00 00	 movzx	 r8d, BYTE PTR isLeap$[rbp]
  000e6	8b 95 08 01 00
	00		 mov	 edx, DWORD PTR currentMonth$[rbp]
  000ec	8b 8d 00 01 00
	00		 mov	 ecx, DWORD PTR currentDay$[rbp]
  000f2	e8 00 00 00 00	 call	 ?getNumberOfDay@@YAHHH_N@Z ; getNumberOfDay
  000f7	8b 8d d4 00 00
	00		 mov	 ecx, DWORD PTR tv81[rbp]
  000fd	2b c8		 sub	 ecx, eax
  000ff	8b c1		 mov	 eax, ecx
$LN1@getNumberB:

; 26   : }

  00101	48 8d a5 e8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+232]
  00108	5f		 pop	 rdi
  00109	5d		 pop	 rbp
  0010a	c3		 ret	 0
?getNumberByBD@@YAHHHHHH_N@Z ENDP			; getNumberByBD
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\учеба\КПО лр\лр3\lab_03\lab1\getNumberOfDay.cpp
;	COMDAT ?getNumberOfDay@@YAHHH_N@Z
_TEXT	SEGMENT
number$ = 4
i$1 = 36
day$ = 288
month$ = 296
isLeap$ = 304
?getNumberOfDay@@YAHHH_N@Z PROC				; getNumberOfDay, COMDAT

; 2    : int getNumberOfDay(int day, int month, bool isLeap) {

$LN7:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000d	55		 push	 rbp
  0000e	57		 push	 rdi
  0000f	48 81 ec 28 01
	00 00		 sub	 rsp, 296		; 00000128H
  00016	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0001b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__BD360EEC_getNumberOfDay@cpp
  00022	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode
  00027	90		 npad	 1

; 3    : 	int number = 0;

  00028	c7 45 04 00 00
	00 00		 mov	 DWORD PTR number$[rbp], 0

; 4    : 
; 5    : 	if (!isLeap) {

  0002f	0f b6 85 30 01
	00 00		 movzx	 eax, BYTE PTR isLeap$[rbp]
  00036	85 c0		 test	 eax, eax
  00038	75 18		 jne	 SHORT $LN5@getNumberO

; 6    : 		months[1].second = 28;

  0003a	ba 01 00 00 00	 mov	 edx, 1
  0003f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?months@@3V?$vector@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@A ; months
  00046	e8 00 00 00 00	 call	 ??A?$vector@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@QEAAAEAU?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@1@_K@Z ; std::vector<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int> > >::operator[]
  0004b	c7 40 28 1c 00
	00 00		 mov	 DWORD PTR [rax+40], 28
$LN5@getNumberO:

; 7    : 	}
; 8    : 
; 9    : 	for (int i = 0; i != month - 1; ++i) {

  00052	c7 45 24 00 00
	00 00		 mov	 DWORD PTR i$1[rbp], 0
  00059	eb 08		 jmp	 SHORT $LN4@getNumberO
$LN2@getNumberO:
  0005b	8b 45 24	 mov	 eax, DWORD PTR i$1[rbp]
  0005e	ff c0		 inc	 eax
  00060	89 45 24	 mov	 DWORD PTR i$1[rbp], eax
$LN4@getNumberO:
  00063	8b 85 28 01 00
	00		 mov	 eax, DWORD PTR month$[rbp]
  00069	ff c8		 dec	 eax
  0006b	39 45 24	 cmp	 DWORD PTR i$1[rbp], eax
  0006e	74 22		 je	 SHORT $LN3@getNumberO

; 10   : 		number += months[i].second;

  00070	48 63 45 24	 movsxd	 rax, DWORD PTR i$1[rbp]
  00074	48 8b d0	 mov	 rdx, rax
  00077	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?months@@3V?$vector@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@A ; months
  0007e	e8 00 00 00 00	 call	 ??A?$vector@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@QEAAAEAU?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@1@_K@Z ; std::vector<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int> > >::operator[]
  00083	8b 40 28	 mov	 eax, DWORD PTR [rax+40]
  00086	8b 4d 04	 mov	 ecx, DWORD PTR number$[rbp]
  00089	03 c8		 add	 ecx, eax
  0008b	8b c1		 mov	 eax, ecx
  0008d	89 45 04	 mov	 DWORD PTR number$[rbp], eax

; 11   : 	}

  00090	eb c9		 jmp	 SHORT $LN2@getNumberO
$LN3@getNumberO:

; 12   : 	number += day;

  00092	8b 85 20 01 00
	00		 mov	 eax, DWORD PTR day$[rbp]
  00098	8b 4d 04	 mov	 ecx, DWORD PTR number$[rbp]
  0009b	03 c8		 add	 ecx, eax
  0009d	8b c1		 mov	 eax, ecx
  0009f	89 45 04	 mov	 DWORD PTR number$[rbp], eax

; 13   : 	return number;

  000a2	8b 45 04	 mov	 eax, DWORD PTR number$[rbp]

; 14   : }

  000a5	48 8d a5 08 01
	00 00		 lea	 rsp, QWORD PTR [rbp+264]
  000ac	5f		 pop	 rdi
  000ad	5d		 pop	 rbp
  000ae	c3		 ret	 0
?getNumberOfDay@@YAHHH_N@Z ENDP				; getNumberOfDay
_TEXT	ENDS
END
